# -*- coding: utf-8 -*-
# {{cookiecutter.project_name}} - {{cookiecutter.project_description}}
# Copyright (C) 2024 - Centre National d'Etudes Spatiales
# This file is part of {{cookiecutter.project_name}} <{{ cookiecutter.project_url }}>
# SPDX-License-Identifier: Apache-2.0
# Auto-generated by skeleton-python-binary
import pytest
from dockerfile_parse import DockerfileParser
import docker
import re
import requests
import os


class TestOptimize:
    """Conformance Class for size optimization"""
    
    @pytest.fixture
    def dockerfile_parser(self):
        dockerfile_path = 'docker/Dockerfile'
        parser = DockerfileParser(dockerfile_path)
        return parser  
    
    def test_official_docker_images_size_optimization(self, dockerfile_parser):
        """Verify that the size of official Docker images complies with the specified criteria: Base Image: Not exceeding 200 MB"""
        image_name = dockerfile_parser.baseimage
        package, version = image_name.split(':')
        query = requests.get(f"https://hub.docker.com/v2/repositories/library/{package}/tags/{version}/images")
        size = -1
        if query.status_code == 200:
            size = query.json()[0]['size']
        else:
            raise Exception(f"Can't find the {image_name}")
        assert size <= 200 * 1024 * 1024
        
        
    def test_no_temporary_artifacts_in_dockerfile(self, dockerfile_parser):
        """Clean Up Temporary Artifacts
        
        Clean Up Temporary Artifact files, caches, and unnecessary artifacts after each Docker instruction to minimize 
        their inclusion in the final image.
        """
        # Define patterns indicative of clean up temporary artifacts
        patterns = [
            r'apt-get\s+clean',        # apt-get clean
            r'rm\s+-rf\s+\/var\/lib\/apt\/lists\/\*',  # rm -rf /var/lib/apt/lists/*
            r'ldconfig'                # ldconfig
        ]

        # Check if patterns are present in the Dockerfile
        found_patterns = []
        for pattern in patterns:
            if re.search(pattern, dockerfile_parser.content):
                found_patterns.append(pattern)

        # Fail the test if patterns are found
        assert len(found_patterns) == 3, f"Found patterns indicative of clean up temporary artifacts: {found_patterns}"
        
    
    def test_dockerignore_exists(self):
        """Verify that a .dockerignore file exists to exclude unnecessary files and directories during the Docker image build process."""
        assert os.path.exists(".dockerignore"), "Add a .dockerignore"
    
    def test_limit_dockerfile_instructions(self, dockerfile_parser):
        """test_limit_dockerfile_instructions and minimize layers"""
        dockerfile_content = dockerfile_parser.content
        last_from_index = dockerfile_content.rfind('FROM')
        dockerfile_content = dockerfile_content[last_from_index:]        
        layer_instructions = ['FROM', 'RUN', 'COPY', 'ADD', 'WORKDIR', 'EXPOSE', 'ENV', 'USER', 'VOLUME']
        layer_count = 0
        for instruction in layer_instructions:
            layer_count += dockerfile_content.count(instruction)  
        assert layer_count < 5   
        
    
    def test_detect_multi_stage_build(self, dockerfile_parser):
        """Verify that the Dockerfile uses multi-stage builds"""
        assert dockerfile_parser.is_multistage, "The build image is not multi-stage"
    

class TestMaintenance:
    """Conformance Class for maintenability"""
    
    @pytest.fixture
    def dockerfile_parser(self):
        dockerfile_path = 'docker/Dockerfile'
        parser = DockerfileParser(dockerfile_path)
        return parser
    
    @pytest.fixture
    def labels_parser(self, dockerfile_parser):
        return dockerfile_parser.labels    

    def test_has_maintainer_label(self, labels_parser):
        """Confirm that a LABEL instruction is present in the Dockerfile specifying the maintainer."""
        assert 'org.opencontainers.image.authors' in labels_parser.keys(), "LABEL instruction for authors not found"
        assert not labels_parser['org.opencontainers.image.authors'].isspace()
        
    def test_has_version_label(self, labels_parser):
        """Confirm that a LABEL instruction is present in the Dockerfile specifying the build timestamp."""
        assert 'org.opencontainers.image.version' in labels_parser.keys(), "LABEL instruction for version not found"
        assert not labels_parser['org.opencontainers.image.authors'].isspace()        
    
    def test_build_timestamp_label(self, labels_parser):
        """Confirm that a LABEL instruction is present in the Dockerfile specifying the build timestamp."""
        assert 'org.opencontainers.image.created' in labels_parser.keys(), "LABEL instruction for build timestamp not found"
        assert not labels_parser['org.opencontainers.image.created'].isspace()

    def test_has_documentation_label(self, labels_parser):
        """Confirm that a LABEL instruction is present in the Dockerfile specifying the documentation URL."""
        assert 'org.opencontainers.image.created' in labels_parser.keys(), "LABEL instruction for documentation not found"
        assert not labels_parser['org.opencontainers.image.created'].isspace()  
        
    def test_has_source_label(self, labels_parser):
        """Confirm that a LABEL instruction is present in the Dockerfile specifying the source code URL."""
        assert 'org.opencontainers.image.source' in labels_parser.keys(), "LABEL instruction for source not found"
        assert not labels_parser['org.opencontainers.image.source'].isspace()
        
    def test_has_vendor_label(self, labels_parser):
        """Confirm that a LABEL instruction is present in the Dockerfile specifying the distributing entity information."""
        assert 'org.opencontainers.image.vendor' in labels_parser.keys(), "LABEL instruction for vendor not found"
        assert not labels_parser['org.opencontainers.image.vendor'].isspace()  
        
    def test_has_licenses_label(self, labels_parser):
        """Confirm that a LABEL instruction is present in the Dockerfile specifying the software license information."""
        assert 'org.opencontainers.image.licenses' in labels_parser.keys(), "LABEL instruction for licenses not found"
        assert not labels_parser['org.opencontainers.image.licenses'].isspace()   
        
    def test_has_title_label(self, labels_parser):
        """Confirm that a LABEL instruction is present in the Dockerfile specifying the human-readable image title."""
        assert 'org.opencontainers.image.title' in labels_parser.keys(), "LABEL instruction for title not found"
        assert not labels_parser['org.opencontainers.image.title'].isspace()
        
    def test_has_title_description(self, labels_parser):
        """Confirm that a LABEL software description is present in the Dockerfile specifying the human-readable software."""
        assert 'org.opencontainers.image.description' in labels_parser.keys(), "LABEL instruction for description not found"
        assert not labels_parser['org.opencontainers.image.description'].isspace()  
        
    def test_has_mame_label(self, labels_parser):
        """Confirm that the Dockerfile's FROM instruction specifies a particular version of the base image, ensuring build 
        consistency and reducing the risk of unexpected changes"""
        assert 'org.opencontainers.image.ref.name' in labels_parser.keys(), "LABEL instruction for name not found"
        assert not labels_parser['org.opencontainers.image.ref.name'].isspace() 
        
    def test_has_version_from(self, dockerfile_parser):
        """Confirm that the Dockerfile's FROM instruction specifies a particular version of the base image, 
        ensuring build consistency and reducing the risk of unexpected changes"""
        version_pattern = r'^\d+(\.\d+)*(-?[a-zA-Z]+)*$'
        image_name = dockerfile_parser.baseimage
        version_part = image_name.split(":")[-1]
        assert version_part != "latest"
        assert re.match(version_pattern,version_part) is not None
        
class TestSecurity:
    """Conformance Class for security"""
    
    @pytest.fixture
    def dockerfile_parser(self):
        dockerfile_path = 'docker/Dockerfile'
        parser = DockerfileParser(dockerfile_path)
        return parser  
    
    def _is_official_image(self, image_name):
        client = docker.from_env()
        client.images.pull(image_name)
        image_info = client.images.get(image_name)
        return bool(image_info.attrs.get('RepoDigests')) 
    
    def _contains_update_instructions(self, dockerfile_content):
        # Define keywords or patterns indicating update instructions
        update_keywords = ['apt-get update', 'apt update', 'apk update', 'pip install --upgrade', 'pip3 install --upgrade']

        # Check if any of the update keywords are present in the Dockerfile content
        for keyword in update_keywords:
            if keyword in dockerfile_content:
                return True
        return False   
    
    def _contains_user_root(self, dockerfile_content):
        return "USER root" in dockerfile_content            

    def test_is_official_base_image(self, dockerfile_parser):
        """Confirm that the Dockerfile specifies an official base image from a trusted registry."""
        base_image = dockerfile_parser.baseimage
        assert self._is_official_image(base_image), "No official image found in the Dockerfile"

    def test_regularly_updates_base_images_and_dependencies(self, dockerfile_parser):
        """Confirm that the Dockerfile contains instructions for regularly updating base images and dependencies."""
        assert self._contains_update_instructions(dockerfile_parser.content), "No update instructions found in the Dockerfile"

    def test_restrict_user_root_usage(self, dockerfile_parser):
        """Confirm that the Dockerfile restricts the use of 'USER root'."""
        assert not self._contains_user_root(dockerfile_parser.content), "Dockerfile contains 'USER root', which is restricted"
        
class TestRunning:
    """Conformance class with Running"""
    
    @pytest.fixture
    def dockerfile_parser(self):
        dockerfile_path = 'docker/Dockerfile'
        parser = DockerfileParser(dockerfile_path)
        return parser 
    
    def test_contains_workdir(self, dockerfile_parser):
        """Confirms that WORKDIR /app is in the dockerfile content."""
        dockerfile_content = dockerfile_parser.content
        assert "WORKDIR /app" in dockerfile_content, "Dockerfile does not contain the WORKDIR /app"        
