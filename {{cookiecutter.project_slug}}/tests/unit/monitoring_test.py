# -*- coding: utf-8 -*-
# {{cookiecutter.project_name}} - {{cookiecutter.project_description}}
# Copyright (C) 2024 - Centre National d'Etudes Spatiales
# This file is part of {{cookiecutter.project_name}} <{{ cookiecutter.project_url }}>
# SPDX-License-Identifier: Apache-2.0
# Auto-generated by skeleton-python-binary
"""
# Test Suite for UtilsMonitoring Decorators

This test suite focuses on ensuring that the logging and functionality of 
decorators within the `UtilsMonitoring` class are working as expected. 

## Overview of the tests:

1. **Mock logger**: 
   We mock the logger to prevent actual logging during tests, ensuring that 
   we can verify the logging behavior without affecting production logs.

2. **Tests for `io_display` decorator**:
   - `test_io_display_logs_inputs_and_outputs`: 
     This test checks that the `io_display` decorator logs both the inputs and 
     outputs of the function `test_func` when configured to do so.
     
   - `test_io_display_logs_only_inputs`: 
     This test checks that only the input of the function `test_func` is logged 
     when the decorator is configured to log only inputs.
     
   - `test_io_display_logs_only_outputs`: 
     This test ensures that only the output of the function `test_func` is logged 
     when the decorator is set to log only outputs.

3. **Test for `time_spend` decorator**:
   - `test_time_spend_logs_function_duration`: 
     Verifies that the `time_spend` decorator logs the execution duration 
     of the `test_sleep_func` function, checking for proper log formatting.

4. **Test for `measure_memory` decorator**:
   - `test_measure_memory_logs_memory_usage`: 
     Confirms that the `measure_memory` decorator logs memory usage for the 
     function `test_memory_func` which creates a large list, checking that 
     memory information is logged appropriately.
"""
from loguru import logger
import pytest
import time
from {{cookiecutter.project_slug}}.monitoring import UtilsMonitoring
from unittest.mock import MagicMock, ANY, patch

# Mock logger to prevent actual logging during tests
@pytest.fixture(autouse=True)
def mock_logger(mocker):
    mock_logger = mocker.patch('{{cookiecutter.project_slug}}.monitoring.logger', new_callable=MagicMock)
    yield mock_logger

# Tests for the io_display decorator
def test_io_display_logs_inputs_and_outputs(mock_logger):
    @UtilsMonitoring.io_display(input=True, output=True, level="DEBUG")
    def test_func(a, b):
        return a + b

    result = test_func(3, 4)
    assert result == 7
    mock_logger.log.assert_any_call("DEBUG", "Input in the function 'test_func' with args=(3, 4), kwargs={}")
    mock_logger.log.assert_any_call("DEBUG", "Output in the function 'test_func' with result=7")

@patch('{{cookiecutter.project_slug}}.monitoring.logger')
def test_io_display_logs_only_inputs(mock_logger):
    @UtilsMonitoring.io_display(input=True, output=False, level="INFO")
    def test_func(a, b):
        return a * b

    result = test_func(3, 4)
    assert result == 12

    # Check for input logging
    mock_logger.log.assert_any_call("INFO", "Input in the function 'test_func' with args=(3, 4), kwargs={}")

    # Assert that the specific output log message was NOT called
    output_log_message = "Output in the function 'test_func' with result=12"
    assert not any(call[0] == ("INFO", output_log_message) for call in mock_logger.log.call_args_list)

@patch('{{cookiecutter.project_slug}}.monitoring.logger')
def test_io_display_logs_only_outputs(mock_logger):
    @UtilsMonitoring.io_display(input=False, output=True, level="INFO")
    def test_func(a, b):
        return a - b

    result = test_func(10, 3)
    assert result == 7

    # Check for output logging
    mock_logger.log.assert_any_call("INFO", "Output in the function 'test_func' with result=7")

    # Assert that the specific input log message was NOT called
    input_log_message = "Input in the function 'test_func' with args=(10, 3), kwargs={}"
    assert not any(call[0] == ("INFO", input_log_message) for call in mock_logger.log.call_args_list)

# Tests for the time_spend decorator
def test_time_spend_logs_function_duration(mock_logger):
    @UtilsMonitoring.time_spend(level="INFO")
    def test_sleep_func():
        time.sleep(0.1)  # Sleep for 100ms

    test_sleep_func()

    # Assert that logging happened with the appropriate log level and check for the correct message format
    mock_logger.log.assert_any_call(
        "INFO", ANY  # Use ANY to match any string
    )

    # Optionally, you can check for a specific pattern if you want to be more strict
    # For example, checking if the message contains "finished in" and "ms"
    log_calls = [call for call in mock_logger.log.call_args_list]
    assert any("finished in" in str(call) for call in log_calls)

# Tests for the measure_memory decorator
def test_measure_memory_logs_memory_usage(mock_logger):
    @UtilsMonitoring.measure_memory(level="WARNING")
    def test_memory_func():
        return [i for i in range(10000)]  # Create a list

    result = test_memory_func()
    assert len(result) == 10000
    assert mock_logger.log.called  # Check that logging happened
    mock_logger.log.assert_any_call(
        "WARNING", ANY  # Checking if warning logs contain memory information
    )